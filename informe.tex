\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[letterpaper, margin=1in]{geometry}

\title{Miniproyecto FADA - Universidad del Valle}
\date{}
\author{David Santiago Cortés, Alejandro Orozco, Brayan Rincones}

\begin{document}
	\maketitle

	\section{Soluciones Planteadas}
		\textbf{Idea General de la solución:}\\
		Almacenar los animales y sus grandezas en una estructura de datos tipo lista, arreglo o diccionario, 
		se ordena esta estructura de acuerdo a los valores de las grandezas y se guarda utiliza para armar las
		escenas de todas las partes del evento.\\	
		\subsection{$O(n^2)$}
			\textbf{Idea de la solución:}\\
			\textbf{Estructuras de datos utilizadas:} Listas, Diccionarios\\ 
			\textbf{Algoritmo de ordenamiento:} Bucles\\
			\textbf{Lenguaje en el que se implementó:} Python
		
		\subsection{$O(n*\log(n))$}
			\textbf{Idea de la solución:}\\
			\textbf{Estructuras de datos utilizadas:} \\
			\textbf{Algoritmo de ordenamiento:}\\
			\textbf{Lenguaje en el que se implementó:}
		\subsection{$O(n)$}
			\textbf{Idea de la solución:} Después de recolectar los datos de entrada se construye un diccionario que mapea 
			animales a sus respectivas grandezas a partir de la lista de animales y grandezas que se pasaron como parametro de
			entrada. Este diccionario se usará más adelante para apoyar distintas operaciones.\\
			Para atacar el problema se utiliza una estrategia \textit{bottom-up} 
			\begin{enumerate}
				\item Ordenar las escenas localmente: para que todas las escenas del evento queden ordenadas localmente solo basta con ordenar
					las escenas de la apertura. El ordenamiento se hace con una implementación de Counting Sort que ordena una lista de 
					tuplas (animal,grandeza) en orden ascendente de acuerdo a las grandezas. 
				\item Ordenar las escenas de las demás partes (localmente): con el resultado del paso anterior se construye un diccionario/tabla hash
					que relaciona escenas desordenadas con escenas ordenadas, se usa un ciclo que itera sobre cada escena de las m-1
					partes y se reemplaza cada escena en cada parte haciendo la consulta en la tabla hash.
				\item Ordenar todas las escenas: teniendo todas las escenas ordenadas localmente en cada parte, lo que resta es ordenar las escenas
					dentro de sus partes de acuerdo a sus grandezas. El proceso se divide en dos, la primera parte
					se encarga de constuir un diccionario/tabla hash que relacione escenas con su grandeza, para ello se itera sobre 
					apertura y se calcula la grandeza de cada escena, con esta información ordenamos apertura utilizando Counting Sort.\\
					En la segunda parte se itera sobre las siguientes $m-1$ partes y sobre las $k$ escenas de tales partes, se consulta cada escena
					en el diccionario para hallar su grandeza y antes de cambiar a la siguiente parte, se ordenan las escenas de la parte actual
					con Counting Sort. Al finalizar el ciclo externo las escenas dentro de cada parte están ordenadas ascendentemente.

					\begin{enumerate}
						\item Empates: se buscan y se resuelven cada que se ordenan las escenas de una parte. Para detectarlos se usa una función
							que detecta duplicados en una lista utilizando la librería \texttt{collections}. Una vez se saben los indices de los 
							elementos repetidos, se utiliza la función \texttt{remove\_duplicates} que remueve los duplicados con un \texttt{while}
							que va "en reversa" empezando en $i=2$ hasta $0$, $i$ se usa para acceder una tabla hash que mapea animales a grandezas.

					\end{enumerate}
				\item Ordenar las partes: para ordenar las partes es necesario saber las grandezas de cada parte, lo cual se hace en el paso
					anterior cada que se va iterando sobre cada parte y se van almacenando los valores una en una lista. \texttt{sort\_parts}
					entonces fusiona las $m-1$ partes con sus grandezas, generando una lista de tuplas (parte, grandeza) que se le pasa
					como parametro a la función de ordenar.
				\item Estadísticas del evento: 
					\begin{enumerate}
						\item Animal más popular y menos popular: se utiliza una lista de todas
						las escenas que ocurren en el evento (con apertura y las demás partes) y la lista de animales del evento. Con ambas se construye
						una tabla hash que mapea animales a número de veces que aparecieron en escena, como candidato para animal más popular y menos popular
						se tiene obviamente al elemento máximo y mínimo de los valores de la tabla hash, para no dejar por fuera ningún otro animal
						se itera sobre la tabla hash buscando animales distintos al candidato y cuyas apariciones sean iguales a las del candidato. 
						\item Promedio de grandeza del evento: se itera sobre la lista de todas las escenas que tuvieron lugar, se suman sus grandezas
							y se divide entre el número de escenas que se mostraron. Lo mismo también puede lograrse con las partes y sus grandezas.

						\item Escenas de mayor y menor grandeza: se calcula el elemento más grande y más pequeño en la tabla hash que mapea escenas
							a sus grandezas.
					\end{enumerate}
			\end{enumerate}
			\textbf{Estructuras de datos utilizadas:} Listas, tablas hash, tuplas\\
			\textbf{Algoritmo de ordenamiento:} Counting Sort para listas de tuplas (animal, grandeza)\\
			\textbf{Lenguaje en el que se implementó:} Python
	\section{Análisis de Resultados}
		\subsection{$O(n^2)$}
		\subsection{$O(n*\log(n))$}
		\subsection{$O(n)$}
		\section[title]{Instrucciones para la ejecución\footnote{Si se quiere utilizar una entrada propia, por favor revisar el formato de las entradas ya hechas.}}
		\subsection{$O(n^2)$}
		\subsection{$O(n*\log(n))$}
		\subsection{$O(n)$}
			\texttt{./lineal.py run.py <nombre-archivo-entrada>}
	\section{Sets de prueba}

	\section{Conclusiones del proyecto}

\end{document}
